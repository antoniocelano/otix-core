<?php

// Definizione della costante globale BASE_PATH che punta alla directory corrente dello script.
define('BASE_PATH', __DIR__);

// --- Caricamento Autoloader e Dipendenze ---
// Include il file autoloader che si occupa di caricare automaticamente le classi necessarie.
require BASE_PATH . '/autoload.php';
// Importa le classi per l'interazione con il database principale e il database Hub.
use App\Core\Database;
use App\Core\HubDatabase;

// --- Caricamento Variabili d'Ambiente ---
try {
    // Carica la configurazione dei domini da un file.
    $domains = require BASE_PATH . '/config/Domains.php';
    // Controlla se è stato specificato un ambiente di sviluppo nel file di configurazione.
    $selected = $domains['_selected'] ?? '';
    if ($selected && isset($domains[$selected])) {
        // Se un ambiente di sviluppo è selezionato, carica il file .env corrispondente.
        $envFile = $domains[$selected]['env'];
        loadEnv(BASE_PATH . '/' . ltrim($envFile, '/'));
    } else {
        // Altrimenti, carica il file .env predefinito.
        loadEnv(BASE_PATH . '/.env');
    }
} catch (\Exception $e) {
    // Gestisce gli errori di caricamento dell'ambiente, stampando un messaggio a colori e terminando lo script.
    echo "\n\033[31mErrore: Impossibile caricare la configurazione dell'ambiente. Assicurati che 'sources/domains.php' e i file .env siano corretti.\033[0m\n";
    exit(1);
}

/**
 * Classe Artisan: uno strumento da linea di comando per gestire il framework.
 * Fornisce comandi per la gestione delle migrazioni, la pulizia della cache e la creazione di utenti.
 */
class Artisan
{
    /** @var Database L'istanza del database. */
    private $db;
    /** @var string Il percorso della cartella delle migrazioni. */
    private $migrationsPath;

    // --- Costanti per i colori dell'output della console ---
    private const COLOR_SUCCESS = "\033[32m"; // Verde
    private const COLOR_WARNING = "\033[33m"; // Giallo
    private const COLOR_ERROR   = "\033[31m"; // Rosso
    private const COLOR_INFO    = "\033[36m"; // Ciano
    private const COLOR_RESET   = "\033[0m";  // Reset del colore

    /**
     * Costruttore della classe. Inizializza la connessione al database e il percorso delle migrazioni.
     */
    public function __construct()
    {
        try {
            // Crea un'istanza della classe Database per le interazioni.
            $this->db = new Database();
            // Imposta il percorso della cartella delle migrazioni.
            $this->migrationsPath = BASE_PATH . '/database/migrations';
            // Crea la cartella delle migrazioni se non esiste.
            if (!is_dir($this->migrationsPath)) {
                mkdir($this->migrationsPath, 0775, true);
            }
        } catch (\PDOException $e) {
            // Se la connessione al database fallisce, stampa un errore e termina.
            $this->error("Errore di connessione al database: " . $e->getMessage());
            exit(1);
        }
    }

    /**
     * Esegue il comando richiesto dall'utente.
     *
     * @param array $argv Gli argomenti passati da linea di comando.
     */
    public function run(array $argv)
    {
        // Controlla se è stato fornito un comando.
        if (count($argv) < 2) {
            $this->showHelp();
            return;
        }

        // Estrae il comando e un eventuale argomento.
        $command = $argv[1];
        $argument = $argv[2] ?? null;

        // Esegue l'azione appropriata in base al comando.
        switch ($command) {
            case 'make:migration':
                $this->makeMigration($argument);
                break;
            case 'migrate':
                $this->migrate();
                break;
            case 'rollback':
                $this->rollback();
                break;
            case 'status':
                $this->status();
                break;
            case 'cache:clear':
                $this->cleanCache();
                break;
            case 'make:user':
                $this->makeUser($argv[2] ?? null, $argv[3] ?? null, $argv[4] ?? null);
                break;
            case 'make:hub:user':
                $this->makeHubUser($argv[2] ?? null, $argv[3] ?? null, $argv[4] ?? null);
                break;
            default:
                $this->error("Comando non riconosciuto: {$command}");
                $this->showHelp();
                break;
        }
    }

    /**
     * Mostra l'elenco dei comandi disponibili e la loro sintassi.
     */
    private function showHelp()
    {
        echo self::COLOR_WARNING . "\nUso:\n" . self::COLOR_RESET;
        echo "  php do <comando> [argomento]\n\n";
        echo self::COLOR_WARNING . "Comandi disponibili:\n" . self::COLOR_RESET;
        echo "  " . self::COLOR_SUCCESS . "make:migration" . self::COLOR_RESET . " <NomeMigrazione>  Crea un nuovo file di migrazione.\n";
        echo "  " . self::COLOR_SUCCESS . "migrate" . self::COLOR_RESET . "                        Esegue le migrazioni pendenti.\n";
        echo "  " . self::COLOR_SUCCESS . "rollback" . self::COLOR_RESET . "                       Annulla l'ultimo batch di migrazioni.\n";
        echo "  " . self::COLOR_SUCCESS . "status" . self::COLOR_RESET . "                         Mostra lo stato delle migrazioni.\n\n";
        echo "  " . self::COLOR_SUCCESS . "make:user" . self::COLOR_RESET . "      <nome> <email> <password>  Crea un nuovo utente.\n";
        echo "  " . self::COLOR_SUCCESS . "make:hub:user" . self::COLOR_RESET . "  <nome> <email> <password>  Crea un nuovo utente per l'Hub.\n";
    }
    
    /**
     * Comando: Crea un nuovo file di migrazione.
     *
     * @param string|null $name Il nome della migrazione.
     */
    public function makeMigration(?string $name)
    {
        if (!$name) {
            $this->error("È richiesto il nome della migrazione.\n  Uso: php do make:migration <NomeMigrazione>");
            return;
        }
        // Valida il nome della migrazione.
        if (!preg_match('/^[a-zA-Z0-9_]+$/', $name)) {
            $this->error("Il nome della migrazione può contenere solo lettere, numeri e underscore.");
            return;
        }

        // Genera il nome del file e della classe della migrazione con un timestamp.
        $timestamp = date('Y_m_d_His');
        $fileName = "{$timestamp}_{$name}.php";
        $className = 'Migration_' . $timestamp . '_' . $name;
        $filePath = $this->migrationsPath . '/' . $fileName;

        // Ottiene il contenuto del "modello" (stub) per il file di migrazione.
        $stub = $this->getMigrationStub($className);

        // Scrive il contenuto nel nuovo file.
        if (file_put_contents($filePath, $stub)) {
            $this->info("Migrazione creata con successo:");
            echo "  {$fileName}\n";
        } else {
            $this->error("Errore durante la creazione del file di migrazione.");
        }
    }
    
    /**
     * Comando: Esegue le migrazioni pendenti.
     */
    public function migrate()
    {
        // Assicura che la tabella 'migrations' esista.
        $this->ensureMigrationsTableExists();
        // Ottiene l'elenco dei file di migrazione che non sono stati ancora eseguiti.
        $pending = $this->getPendingMigrations();

        if (empty($pending)) {
            $this->info("Nessuna nuova migrazione da eseguire. Il database è aggiornato.");
            return;
        }

        // Calcola il numero del nuovo "batch" di migrazioni.
        $batch = $this->getLastBatchNumber() + 1;
        foreach ($pending as $file) {
            $this->runUp($file, $batch);
        }

        $this->info("\nMigrazioni eseguite con successo.");
    }

    /**
     * Comando: Annulla l'ultimo batch di migrazioni.
     */
    public function rollback()
    {
        $this->ensureMigrationsTableExists();
        // Ottiene il numero dell'ultimo batch di migrazioni.
        $lastBatch = $this->getLastBatchNumber();

        if ($lastBatch === 0) {
            $this->info("Nessuna migrazione da annullare.");
            return;
        }

        // Seleziona le migrazioni dell'ultimo batch, ordinate in modo decrescente.
        $migrationsToRollback = $this->db->select('migrations', ['batch' => $lastBatch], ['migration'], [], ['migration' => 'DESC']);

        if (empty($migrationsToRollback)) {
            $this->info("Nessuna migrazione trovata nel batch #{$lastBatch}.");
            return;
        }

        // Esegue il metodo 'down' per ogni migrazione.
        foreach ($migrationsToRollback as $migration) {
            $this->runDown($migration['migration']);
        }

        $this->info("\nRollback completato con successo.");
    }

    /**
     * Comando: Mostra lo stato di tutte le migrazioni.
     */
    public function status()
    {
        $this->ensureMigrationsTableExists();
        // Ottiene l'elenco delle migrazioni già eseguite.
        $executed = $this->getExecutedMigrations();
        // Ottiene l'elenco di tutti i file di migrazione.
        $allFiles = $this->getAllMigrationFiles();

        echo self::COLOR_WARNING . "\nStato delle Migrazioni\n-----------------------\n" . self::COLOR_RESET;

        if (empty($allFiles)) {
            $this->info("Nessun file di migrazione trovato.");
            return;
        }

        // Itera sui file e mostra il loro stato.
        foreach ($allFiles as $file) {
            $fileName = basename($file);
            if (in_array($fileName, $executed)) {
                echo "[ " . self::COLOR_SUCCESS . "✓ Eseguita" . self::COLOR_RESET . " ] {$fileName}\n";
            } else {
                echo "[ " . self::COLOR_WARNING . "✗ Pendente" . self::COLOR_RESET . " ] {$fileName}\n";
            }
        }
        echo "\n";
    }

    /**
     * Comando: Pulisce la cache delle viste.
     * Rimuove tutti i file HTML generati per la cache.
     */
    public function cleanCache()
    {
        // Imposta il percorso della cache.
        $cachePath = BASE_PATH . '/storage/cache/views';
        
        if (!is_dir($cachePath)) {
            $this->info("La cartella della cache non esiste. Nulla da pulire.");
            return;
        }

        // Ottiene tutti i file .html nella cartella.
        $files = glob($cachePath . '/*.html');
        
        if (empty($files)) {
            $this->info("La cache delle viste è già vuota.");
            return;
        }

        $count = 0;
        foreach ($files as $file) {
            // Elimina ogni file singolarmente.
            if (is_file($file)) {
                unlink($file);
                $count++;
            }
        }

        $this->info("Cache delle viste pulita con successo. Rimossi {$count} file.");
    }

    /**
     * Comando: Crea un nuovo utente nel database principale.
     *
     * @param string|null $name Il nome dell'utente.
     * @param string|null $email L'email dell'utente.
     * @param string|null $password La password dell'utente.
     */
    public function makeUser(?string $name, ?string $email, ?string $password)
    {
        if (!$name || !$email || !$password) {
            $this->error("Tutti i campi sono obbligatori.\n  Uso: php do make:user <nome> <email> <password>");
            return;
        }

        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this->error("L'indirizzo email non è valido.");
            return;
        }

        try {
            // Hasha la password prima di salvarla.
            $hashedPassword = password_hash($password, PASSWORD_DEFAULT);

            // Inserisce i dati dell'utente nella tabella 'users'.
            $this->db->insert('users', [
                'name' => $name,
                'email' => $email,
                'password' => $hashedPassword,
            ]);

            $this->info("Utente '{$name}' creato con successo!");

        } catch (\PDOException $e) {
            // Gestisce l'errore di email duplicata.
            if ($e->errorInfo[1] == 1062) {
                $this->error("Errore: L'email '{$email}' esiste già nel database.");
            } else {
                $this->error("Errore del database durante la creazione dell'utente: " . $e->getMessage());
            }
        } catch (\Exception $e) {
            $this->error("Errore generico: " . $e->getMessage());
        }
    }

    /**
     * Comando: Crea un nuovo utente nel database Hub.
     *
     * @param string|null $name Il nome dell'utente.
     * @param string|null $email L'email dell'utente.
     * @param string|null $password La password dell'utente.
     */
    public function makeHubUser(?string $name, ?string $email, ?string $password)
    {
        if (!$name || !$email || !$password) {
            $this->error("Tutti i campi sono obbligatori.\n  Uso: php do make:hub:user <nome> <email> <password>");
            return;
        }

        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            $this->error("L'indirizzo email non è valido.");
            return;
        }

        try {
            // Crea un'istanza di HubDatabase per connettersi al database specifico.
            $hubDb = new HubDatabase();
            $hashedPassword = password_hash($password, PASSWORD_DEFAULT);
            $now = date('Y-m-d H:i:s');

            // Inserisce i dati dell'utente nella tabella 'users' del database Hub.
            $hubDb->insert('users', [
                'name' => $name,
                'email' => $email,
                'password' => $hashedPassword,
                'remember_token' => null,
                'created_at' => $now,
                'updated_at' => $now,
            ]);

            $this->info("Utente HUB '{$name}' creato con successo!");

        } catch (\PDOException $e) {
            // Gestisce l'errore di email duplicata nel database Hub.
            if ($e->errorInfo[1] == 1062) {
                $this->error("Errore: L'email '{$email}' esiste già nel database HUB.");
            } else {
                $this->error("Errore del database durante la creazione dell'utente HUB: " . $e->getMessage());
            }
        } catch (\Exception $e) {
            $this->error("Errore generico: " . $e->getMessage());
        }
    }

    /**
     * --------------------------------------------------------------------------
     * Funzioni Core per le Migrazioni
     * --------------------------------------------------------------------------
     */

    /**
     * Assicura che la tabella delle migrazioni esista.
     * Se non esiste, la crea.
     */
    private function ensureMigrationsTableExists()
    {
        try {
            $this->db->query("CREATE TABLE IF NOT EXISTS migrations (
                id INT AUTO_INCREMENT PRIMARY KEY,
                migration VARCHAR(255) NOT NULL,
                batch INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )");
        } catch (\PDOException $e) {
            $this->error("Impossibile creare la tabella delle migrazioni: " . $e->getMessage());
            exit(1);
        }
    }

    /**
     * Esegue il metodo 'up' di una singola migrazione.
     *
     * @param string $file Il percorso completo del file di migrazione.
     * @param int $batch Il numero del batch.
     */
    private function runUp($file, $batch)
    {
        $fileName = basename($file);
        $this->write("Esecuzione in corso:", $fileName);
        
        try {
            // Crea un'istanza della classe di migrazione.
            $migration = $this->instantiateMigration($file);
            $migration->up(); // Chiama il metodo up().
            $this->logMigration($fileName, $batch); // Registra la migrazione nel database.
            $this->write(self::COLOR_SUCCESS . "Eseguita" . self::COLOR_RESET . "           :", $fileName, true);
        } catch (\Exception $e) {
            $this->error("\n\n!! ERRORE DURANTE L'ESECUZIONE DI {$fileName} !!\nMessaggio: " . $e->getMessage() . "\n");
            exit(1);
        }
    }

    /**
     * Esegue il metodo 'down' di una singola migrazione.
     *
     * @param string $fileName Il nome del file di migrazione.
     */
    private function runDown($fileName)
    {
        $this->write("Annullamento in corso:", $fileName);

        try {
            $file = $this->migrationsPath . '/' . $fileName;
            if (!file_exists($file)) {
                throw new \Exception("File di migrazione non trovato. Rimuovo la registrazione dal DB.");
            }
            $migration = $this->instantiateMigration($file);
            $migration->down(); // Chiama il metodo down().
            $this->db->delete('migrations', ['migration' => $fileName]); // Rimuove il record dal database.
            $this->write(self::COLOR_SUCCESS . "Annullata" . self::COLOR_RESET . "            :", $fileName, true);
        } catch (\Exception $e) {
            if (strpos($e->getMessage(), "File di migrazione non trovato") !== false) {
                 $this->db->delete('migrations', ['migration' => $fileName]);
                 $this->warning("\n{$e->getMessage()}");
            } else {
                $this->error("\n\n!! ERRORE DURANTE IL ROLLBACK DI {$fileName} !!\nMessaggio: " . $e->getMessage() . "\n");
                exit(1);
            }
        }
    }
    
    /**
     * Include e istanzia una classe di migrazione.
     *
     * @param string $file Il percorso del file.
     * @return object L'istanza della classe di migrazione.
     * @throws \Exception Se la classe non viene trovata.
     */
    private function instantiateMigration(string $file): object
    {
        require_once $file;
        $fileName = basename($file);
        // Costruisce il nome della classe.
        $className = 'Migration_' . str_replace('.php', '', $fileName);

        if (!class_exists($className)) {
            throw new \Exception("Classe '{$className}' non trovata nel file '{$fileName}'.");
        }
        return new $className();
    }

    /**
     * Genera il contenuto di base per un nuovo file di migrazione.
     *
     * @param string $className Il nome della classe.
     * @return string Il codice PHP per la migrazione.
     */
    private function getMigrationStub(string $className): string
    {
        return <<<EOT
<?php

use App\Core\Database;

class {$className}
{
    private \$db;

    public function __construct()
    {
        \$this->db = new Database();
    }

    /**
     * Esegue la migrazione.
     * Applica le modifiche allo schema del database.
     */
    public function up()
    {
        // Esempio: \$this->db->query("CREATE TABLE users (...)");
    }

    /**
     * Annulla la migrazione.
     * Rimuove le modifiche apportate dal metodo up().
     */
    public function down()
    {
        // Esempio: \$this->db->query("DROP TABLE IF EXISTS users");
    }
}
EOT;
    }

    /**
     * Ottiene l'elenco dei file di migrazione ancora da eseguire.
     *
     * @return array Un array di percorsi di file.
     */
    private function getPendingMigrations(): array
    {
        $executed = $this->getExecutedMigrations();
        $allFiles = $this->getAllMigrationFiles();
        // Filtra i file non ancora eseguiti.
        return array_filter($allFiles, fn($file) => !in_array(basename($file), $executed));
    }

    /**
     * Ottiene l'elenco dei nomi di file delle migrazioni già eseguite.
     *
     * @return array Un array di nomi di file.
     */
    private function getExecutedMigrations(): array
    {
        try {
            $results = $this->db->select('migrations', [], ['migration']);
            return array_column($results, 'migration');
        } catch (\PDOException $e) {
            return []; // Se la tabella non esiste, non ci sono migrazioni eseguite.
        }
    }

    /**
     * Ottiene l'elenco completo di tutti i file di migrazione.
     *
     * @return array Un array di percorsi di file.
     */
    private function getAllMigrationFiles(): array
    {
        $files = glob($this->migrationsPath . '/*.php');
        sort($files); // Ordina i file per nome (che include il timestamp).
        return $files;
    }

    /**
     * Registra una migrazione eseguita nella tabella delle migrazioni.
     *
     * @param string $migration Il nome del file della migrazione.
     * @param int $batch Il numero del batch.
     */
    private function logMigration(string $migration, int $batch): void
    {
        $this->db->insert('migrations', ['migration' => $migration, 'batch' => $batch]);
    }

    /**
     * Ottiene il numero dell'ultimo batch di migrazioni eseguito.
     *
     * @return int L'ultimo numero di batch o 0 se non ci sono migrazioni.
     */
    private function getLastBatchNumber(): int
    {
        try {
            $result = $this->db->query("SELECT MAX(batch) as max_batch FROM migrations");
            return (int)($result[0]['max_batch'] ?? 0);
        } catch (\PDOException $e) {
            return 0; // In caso di errore (es. tabella non esistente), ritorna 0.
        }
    }

    // --- Funzioni per l'Output a Colori ---
    private function info(string $message): void    { echo self::COLOR_INFO    . $message . self::COLOR_RESET . "\n"; }
    private function error(string $message): void   { echo self::COLOR_ERROR   . $message . self::COLOR_RESET . "\n"; }
    private function warning(string $message): void { echo self::COLOR_WARNING . $message . self::COLOR_RESET . "\n"; }
    private function write(string $status, string $message, bool $overwrite = false): void {
        echo ($overwrite ? "\r" : "") . $status . " " . self::COLOR_RESET . $message . ($overwrite ? "\n" : "");
    }
}

// --- Esecuzione ---
// Crea un'istanza della classe Artisan.
$artisan = new Artisan();
// Esegue il comando passato da linea di comando.
$artisan->run($argv);